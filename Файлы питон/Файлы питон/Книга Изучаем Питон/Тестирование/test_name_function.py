import unittest
from function_name import get_formated_name


class NameTestCase(unittest.TestCase):
    """Тесты для function_name"""

    def test_first_last_name(self):
        """Имена типа Jimmy Hendrix работают правильно ?"""
        formated_name = get_formated_name('jimmy','hendrix')
        self.assertEqual(formated_name, 'Jimmy Hendrix')

    def test_first_middle_last_name(self):
        """Имена типа Wolfgang Amadeus Mozart работают правильно ?"""
        formated_name = get_formated_name('wolfgang','mozart','amadeus')
        self.assertEqual(formated_name,'Wolfgang Amadeus Mozart')


if __name__ == '__main__':
    unittest.main()

# Сначала мы импортируем unittest и тестируемую функцию get_formatted_name().
# В точке  создается класс NamesTestCase, который содержит серию модульных
# тестов для get_formatted_name(). Имя класса выбирается произвольно, но лучше
# выбрать имя, связанное с функцией, которую вы собираетесь тестировать, и включить в имя класса слово Test. Этот класс должен наследовать от класса unittest.
# TestCase, чтобы Python знал, как запустить написанные вами тесты.
# Класс NamesTestCase содержит один метод, который тестирует всего один аспект
# get_formatted_name() — правильность форматирования имен, состоящих только из
# Тестирование функции 225
# имени и фамилии. Мы назвали этот метод test_first_last_name(). Любой метод,
# имя которого начинается с test_, будет выполняться автоматически при запуске
# test_name_function.py. В тестовом методе вызывается тестируемая функция и сохраняется возвращаемое значение, которое необходимо проверить. В данном примере
# вызывается функция get_formatted_name() с аргументами 'janis' и 'joplin',
# а результат сохраняется в переменной formatted_name .
# В точке  используется одна из самых полезных особенностей unittest: метод
# assert. Методы assert проверяют, что полученный результат соответствует тому
# результату, который вы рассчитывали получить. В данном случае известно, что
# функция get_formatted_name() должна вернуть полное имя с пробелами и капитализацией слов, поэтому переменная formatted_name должна содержать текст «Janis
# Joplin». Чтобы убедиться в этом, мы используем метод assertEqual() из модуля
# unittest и передаем ему переменную formatted_name и строку 'Janis Joplin'. Вызов
# self.assertEqual(formatted_name, 'Janis Joplin')
# означает: «Сравни значение formatted_name со строкой 'Janis Joplin'. Если они
# равны, как и ожидалось, — хорошо. Но если они не равны, обязательно сообщи
# мне!»
# Мы запустим этот файл напрямую, но важно заметить, что многие тестовые фреймворки импортируют ваши тестовые файлы перед их выполнением. При импортировании файла интерпретатор выполняет файл в процессе импортирования. Блок if
# в точке  проверяет специальную переменную __name__, значение которой задается
# при выполнении программы. Если файл выполняется как главная программа, то
# переменной __name__ будет присвоено значение '__main__'. В этом случае вызывается метод unittest.main(), который выполняет тестовый сценарий. Если файл
# импортируется тестовым сценарием, то переменная __name__ будет содержать
# значение '__main__', и этот блок выполняться не будет
